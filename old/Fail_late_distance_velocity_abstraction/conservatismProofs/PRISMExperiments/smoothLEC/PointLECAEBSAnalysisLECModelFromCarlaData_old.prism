mdp

// AEBS Parameters
//const int B1=1000;
//const int B2=2000;
//const int TTCThresh = 10;
//const int xwarning = 2000;
//const int freq = 10;
//const int fmu=1;
//const int Thd=1;

const int B1=40; // approximates high end of comfortable human braking from doc from China (3.4 rounded to 4)
const int B2=80; // Comes from michigan.gov braking test document (8.2 rounded to 8)
const int TTCThresh = 6; // idk
const int xwarning = 10; // point at which human cannot stop car manually, so our system must brake
const int freq = 10; // We pick this, approximates running speed of yolonet
const int fmu=1; // ignoring affects of road conditions on braking for the sake of the case study
const int Thd=2; // In middle of range of driver reaction times (see research gate doc from Finland)

const int initPos;
const int initSpeed;

const int initBrakingFlag;
const int initBraking;


module LECMarkovChain

    s : [0..1] init 1;  // 0 is detect, 1 is misdetect

    carSpeed : [0 .. initSpeed] init initSpeed;
    carPos : [0..initPos] init initPos;

    seqflag : [0..2] init initBrakingFlag;         
    contRegion : [0..2] init 0;

    //TTC = carPos/carSpeed;
    //xwarning = (carPos-fmu*pow(carSpeed,2)/(2*B2))/(carSpeed*Thd)
    // compute controller region
    [] seqflag=0&((carPos-50)/carSpeed)>TTCThresh&((carPos-50)-fmu*pow(carSpeed,2)/(2*B2))/(carSpeed*Thd)>xwarning ->   (seqflag'=1)&(contRegion'=0); // safe region
    [] seqflag=0&((carPos-50)/carSpeed)>TTCThresh&((carPos-50)-fmu*pow(carSpeed,2)/(2*B2))/(carSpeed*Thd)<=xwarning ->  (seqflag'=1)&(contRegion'=1); // braking region
    [] seqflag=0&((carPos-50)/carSpeed)<=TTCThresh&((carPos-50)-fmu*pow(carSpeed,2)/(2*B2))/(carSpeed*Thd)>xwarning ->  (seqflag'=1)&(contRegion'=1); // braking region
    [] seqflag=0&((carPos-50)/carSpeed)<=TTCThresh&((carPos-50)-fmu*pow(carSpeed,2)/(2*B2))/(carSpeed*Thd)<=xwarning -> (seqflag'=1)&(contRegion'=2); // collision mitigation region

    // compute LEC reading
    [] seqflag=1&carPos<100&carPos>=0 -> 0.9703015189299479:(s'=0)&(seqflag'=2)+ 0.02969848107005213:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<200&carPos>=100 -> 0.9946675031367629:(s'=0)&(seqflag'=2)+ 0.005332496863237113:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<300&carPos>=200 -> 0.9314692982456141:(s'=0)&(seqflag'=2)+ 0.06853070175438591:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<400&carPos>=300 -> 0.9064327485380117:(s'=0)&(seqflag'=2)+ 0.0935672514619883:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<500&carPos>=400 -> 0.8595317725752508:(s'=0)&(seqflag'=2)+ 0.14046822742474918:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<600&carPos>=500 -> 0.8178525226390686:(s'=0)&(seqflag'=2)+ 0.1821474773609314:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<700&carPos>=600 -> 0.6618741976893453:(s'=0)&(seqflag'=2)+ 0.3381258023106547:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<800&carPos>=700 -> 0.5651271406331084:(s'=0)&(seqflag'=2)+ 0.4348728593668916:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<900&carPos>=800 -> 0.1771047227926078:(s'=0)&(seqflag'=2)+ 0.8228952772073922:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1000&carPos>=900 -> 0.01528101528101528:(s'=0)&(seqflag'=2)+ 0.9847189847189847:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1100&carPos>=1000 -> 0.007188703465982028:(s'=0)&(seqflag'=2)+ 0.992811296534018:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1200&carPos>=1100 -> 0.0002592016588906169:(s'=0)&(seqflag'=2)+ 0.9997407983411094:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1300&carPos>=1200 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1400&carPos>=1300 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1500&carPos>=1400 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1600&carPos>=1500 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1700&carPos>=1600 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1800&carPos>=1700 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<1900&carPos>=1800 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);
    [] seqflag=1&carPos<2000&carPos>=1900 -> 0.0:(s'=0)&(seqflag'=2)+ 1.0:(s'=1)&(seqflag'=2);


	
    // compute carPos, carSpeed
    [] seqflag=2&s=0&contRegion=0&carSpeed>0&carPos>0 -> (carPos'=carPos-ceil(carSpeed/freq))&(seqflag'=0);
    [] seqflag=2&s=0&contRegion=1&carSpeed>0&carPos>0 -> (carPos'=carPos-ceil(carSpeed/freq))&(carSpeed'=carSpeed-floor(B1/freq))&(seqflag'=0);
    [] seqflag=2&s=0&contRegion=2&carSpeed>0&carPos>0 -> (carPos'=carPos-ceil(carSpeed/freq))&(carSpeed'=carSpeed-floor(B2/freq))&(seqflag'=0);
    [] seqflag=2&s=1&contRegion=0&carSpeed>0&carPos>0 -> (carPos'=carPos-ceil(carSpeed/freq))&(seqflag'=0);
    [] seqflag=2&s=1&contRegion=1&carSpeed>0&carPos>0 -> (carPos'=carPos-ceil(carSpeed/freq))&(seqflag'=0);
    [] seqflag=2&s=1&contRegion=2&carSpeed>0&carPos>0 -> (carPos'=carPos-ceil(carSpeed/freq))&(seqflag'=0);

endmodule